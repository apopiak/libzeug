#pragma once

#include <reflectionzeug/reflectionzeug_api.h>

#include <reflectionzeug/AbstractDeserializer.h>


#include <list>

#include <reflectionzeug/Variant.h>
#include <reflectionzeug/regex_namespace.h>

namespace reflectionzeug
{

class PropertyGroup;

/**
 * \brief Loads values of a property hierachy from a JSON file.
 * This is not a complete JSON parser and should never be used as such.
 * It is only suitable for the JSON files generated by the JsonFromVariantSerializer
 * \see JsonFromVariantSerializer
 */
class REFLECTIONZEUG_API JsonToVariantDeserializer : public AbstractDeserializer
{
public:
    JsonToVariantDeserializer();
    virtual ~JsonToVariantDeserializer();

    virtual Variant fromStream(std::istream & inStream) override;
    virtual Variant fromStream(std::istream & inStream, bool & successFlag) override;
    virtual Variant fromFile(const std::string & filePath) override;
    virtual Variant fromFile(const std::string & filePath, bool & successFlag) override;
    virtual Variant fromString(const std::string & str) override;
    virtual Variant fromString(const std::string & str, bool & successFlag) override;

protected:
    Variant deserialize(std::istream & inStream, bool & successFlag);

    bool isMapDeclaration(const std::string & line);
    bool isMapEnd(const std::string & line);

    bool isArrayDeclaration(const std::string &line);
    bool isArrayEnd(const std::string &line);

    bool isValueDeclaration(const std::string & line);

    bool insert(Variant variant);

    void endMap();
    void endArray();

    //bool setPropertyValue(const std::string & line);

    Variant constructVariant(const std::string & value) const;

protected:
    Variant m_rootVariant;
    regex_namespace::smatch m_matches;
    std::list<Variant *> m_variantGroupList;
    Variant * m_currentVariant;
};

} // namespace reflectionzeug
